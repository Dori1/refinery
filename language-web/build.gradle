plugins {
	id 'java'
	id 'application'
	alias libs.plugins.frontend
	alias libs.plugins.shadow
	id 'tools.refinery.xtext-conventions'
	id 'tools.refinery.junit-conventions'
}

import org.siouan.frontendgradleplugin.infrastructure.gradle.RunNpmYarn

dependencies {
	implementation project(':refinery-language')
	implementation project(':refinery-language-ide')
	implementation libs.xtend.lib
	implementation libs.xtext.web
	implementation libs.jetty.server
	implementation libs.jetty.servlet
	implementation libs.jetty.websocket.server
	implementation libs.slf4j.simple
	implementation libs.slf4j.log4j
	testImplementation testFixtures(project(':refinery-language'))
	testImplementation libs.jetty.websocket.client
}

def generateXtextLanguage = project(':refinery-language').tasks.named('generateXtextLanguage')

for (taskName in ['compileJava', 'processResources']) {
	tasks.named(taskName) {
		dependsOn generateXtextLanguage
	}
}

def webpackOutputDir = "${buildDir}/webpack"
def productionResources = "${webpackOutputDir}/production"
def serverMainClass = 'tools.refinery.language.web.ServerLauncher'
def nodeDirectory = "${rootDir}/.gradle/node"

frontend {
	nodeVersion = project.ext.nodeVersion
	nodeInstallDirectory = file(nodeDirectory)
	yarnEnabled = true
	yarnVersion = project.ext.yarnVersion
	yarnInstallDirectory = file("${rootDir}/.gradle/yarn")
	assembleScript = 'run assemble:webpack'
}

def installFrontend = tasks.named('installFrontend')

def generateLezerGrammar = tasks.register('generateLezerGrammar', RunNpmYarn) {
	dependsOn installFrontend
	inputs.file('src/main/js/language/problem.grammar')
	inputs.files('package.json', 'yarn.lock')
	outputs.file "${buildDir}/generated/sources/lezer/problem.ts"
	outputs.file "${buildDir}/generated/sources/lezer/problem.terms.ts"
	script = 'run assemble:lezer'
}

def assembleFrontend = tasks.named('assembleFrontend')
assembleFrontend.configure {
	dependsOn generateLezerGrammar
	inputs.dir 'src/main/css'
	inputs.dir 'src/main/html'
	inputs.dir 'src/main/js'
	inputs.file "${buildDir}/generated/sources/lezer/problem.ts"
	inputs.file "${buildDir}/generated/sources/lezer/problem.terms.ts"
	inputs.files('package.json', 'yarn.lock', 'webpack.config.js')
	outputs.dir productionResources
}

def eslint = tasks.register('eslint', RunNpmYarn) {
	dependsOn installFrontend
	inputs.dir 'src/main/js'
	inputs.files('.eslintrc.js', 'tsconfig.json')
	if (project.hasProperty('ci')) {
		outputs.file "${buildDir}/eslint.json"
		script = 'run check:eslint:ci'
	} else {
		script = 'run check:eslint'
	}
	group = 'verification'
	description = 'Check for TypeScript errors.'
}

def stylelint = tasks.register('stylelint', RunNpmYarn) {
	dependsOn installFrontend
	inputs.dir 'src/main/css'
	inputs.file '.stylelintrc.js'
	if (project.hasProperty('ci')) {
		outputs.file "${buildDir}/stylelint.json"
		script = 'run check:stylelint:ci'
	} else {
		script = 'run check:stylelint'
	}
	group = 'verification'
	description = 'Check for Sass errors.'
}

tasks.named('check') {
	dependsOn(eslint, stylelint)
}

tasks.named('jar') {
	dependsOn assembleFrontend
	from(productionResources) {
		into 'webapp'
	}
}

mainClassName = serverMainClass
distTar.enabled = false
distZip.enabled = false

shadowDistTar.enabled = false
shadowDistZip.enabled = false

tasks.named('shadowJar') {
	dependsOn assembleFrontend
	from(project.convention.getPlugin(JavaPluginConvention).sourceSets.main.output)
	configurations = [project.configurations.runtimeClasspath]
	exclude('META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA','schema/*',
		'.options', '.api_description', '*.profile', 'about.*', 'about_*.html', 'about_files/*',
		'plugin.xml', 'systembundle.properties', 'profile.list', 'META-INF/resources/xtext/**')
	append('plugin.properties')
	from(productionResources) {
		into 'webapp'
	}
}

def jettyRun = tasks.register('jettyRun', JavaExec) {
	dependsOn assembleFrontend
	dependsOn sourceSets.main.runtimeClasspath
	classpath = sourceSets.main.runtimeClasspath.filter{it.exists()}
	mainClass = serverMainClass
	standardInput = System.in
	environment BASE_RESOURCE: productionResources
	group = 'run'
	description = 'Start a Jetty web server serving the Xtex API and assets (without rebuilding assets).'
}

tasks.register('webpackServe', RunNpmYarn) {
	dependsOn installFrontend
	dependsOn generateLezerGrammar
	outputs.dir "${webpackOutputDir}/development"
	script = 'run serve'
	group = 'run'
	description = 'Start a Webpack dev server with hot module replacement.'
}

sonarqube.properties {
	properties['sonar.sources'] += [
		'src/main/css',
		'src/main/html',
		'src/main/js',
	]
	property 'sonar.nodejs.executable', "${nodeDirectory}/bin/node"
	property 'sonar.eslint.reportPaths', "${buildDir}/eslint.json"
	property 'sonar.css.stylelint.reportPaths', "${buildDir}/stylelint.json"
	// SonarJS does not pick up typescript files with `exactOptionalPropertyTypes`
	property 'sonar.typescript.tsconfigPath', 'tsconfig.sonar.json'
}
