@detectDelim

@external prop implicitCompletion from './props'

@precedence {
  containment @cut,
  prefix,
  exponential @right,
  multiplicative @left,
  additive @left,
  comparison @left
}

@top Problem { statement* }

statement {
  ProblemDeclaration {
    kw<"problem"> QualifiedName "."
  } |
  ClassDefinition {
    kw<"abstract">? kw<"class"> RelationName
    (kw<"extends"> sep<",", RelationName>)?
    (ClassBody {  "{" ReferenceDeclaration* "}" } | ".")
  } |
  EnumDefinition {
    kw<"enum"> RelationName
    (EnumBody { "{" sep<",", IndividualNodeName> "}" } | ".")
  } |
  PredicateDefinition {
    (
      (kw<"error"> | ckw<"contained"> | kw<"containment">)? kw<"pred"> |
      kw<"error">
    )
    RelationName ParameterList<Parameter>?
    PredicateBody { ("<->" sep<OrOp, Conjunction>)? "." }
  } |
  FunctionDefinition {
    RelationName RelationName ParameterList<Parameter>?
    FunctionBody { ("=" sep<OrOp, Case>)? "." }
  } |
  //RuleDefinition {
  //  kw<"rule">
  //  RuleName ParameterList<Parameter>?
  //  RuleBody { ":" sep<OrOp, Conjunction> "==>" sep<OrOp, Consequent> "." }
  //} |
  Assertion {
    kw<"default">? (NotOp | UnknownOp)? RelationName
    ParameterList<AssertionArgument> (":" LogicValue)? "."
  } |
  NodeValueAssertion {
    QualifiedName ":" Constant "."
  } |
  IndividualDeclaration {
    kw<"individual"> sep<",", IndividualNodeName> "."
  } |
  ScopeDeclaration {
    kw<"scope"> sep<",", ScopeElement> "."
  }
}

ReferenceDeclaration {
  (
    ExplicitContainmentReference {
      !containment (kw<"refers"> | ckw<"contains"> | kw<"container">) RelationName
    } |
    ImplicitContainmentReference {
      RelationName
    }
  )
  ("[" Multiplicity? "]")?
  RelationName
  (kw<"opposite"> RelationName)?
  ";"?
}

Parameter { Modality? RelationName? VariableName }

Conjunction { ("," | Expr)+ }

Case { Conjunction ("->" Expr)? }

OrOp { ";" }

Expr {
  UnaryExpr | BinaryExpr | Aggregation | VariableName | Atom | Constant | "(" Expr ")"
}

BinaryExpr[@dynamicPrecedence=1] {
  Expr !comparison ComparisonOp Expr |
  Expr !additive ("+" | "-") Expr |
  Expr !multiplicative (StarMult | Divide) Expr |
  Expr !exponential "**" Expr
}

UnaryExpr {
  !prefix ("+" | "-" | "!" | "#" | Modality) Expr
}

Aggregation {
  AggregationOp "{" Expr "|" Expr "}"
}

Atom { RelationName "+"? ParameterList<Expr> }

//Consequent { ("," | Action)+ }

//Action {
//   ckw<"new"> VariableName ("<:" VariableName)? |
//   kw<"delete"> VariableName |
//   Literal
//}

AssertionArgument { NodeName | StarArgument | Constant }

Constant { Real | String }

LogicValue {
  ckw<"true"> | ckw<"false"> | kw<"unknown"> | kw<"error">
}

Modality {
  kw<"must"> | kw<"may"> | kw<"current">
}

AggregationOp {
  ckw<"sum"> | ckw<"prod"> | ckw<"min"> | ckw<"max">
}

ScopeElement { RelationName ("=" | "+=") Multiplicity }

Multiplicity { (IntMult "..")? (IntMult | StarMult)}

RelationName { QualifiedName ~name }

//RuleName { QualifiedName }

IndividualNodeName { QualifiedName }

VariableName[@dynamicPrecedence=10] { QualifiedName ~name }

NodeName { QualifiedName }

QualifiedName[implicitCompletion=true] { identifier ("::" identifier)* }

kw<term> { @specialize[@name={term},implicitCompletion=true]<identifier, term> }

ckw<term> { @extend[@name={term},implicitCompletion=true]<identifier, term> }

ParameterList<content> { "(" sep<",", content> ")" }

sep<separator, content> { sep1<separator, content>? }

sep1<separator, content> { content (separator content)* }

@skip { LineComment | BlockComment | whitespace }

@tokens {
  whitespace { std.whitespace+ }

  LineComment { ("//" | "%") ![\n]* }

  BlockComment { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  Divide { "/" }

  @precedence { BlockComment, LineComment, Divide }

  identifier { $[A-Za-z_] $[a-zA-Z0-9_]* }

  int { $[0-9]+ }

  IntMult { int }

  StarMult { "*" }

  Real { (exponential | int ("." (int | exponential))?) }

  exponential { int ("e" | "E") ("+" | "-")? int }

  String {
    "'" (![\\'\n] | "\\" ![\n] | "\\\n")+ "'" |
    "\"" (![\\"\n] | "\\" (![\n] | "\n"))* "\""
  }

  ComparisonOp { ">" | ">=" | "<" | "<=" | "==" | "!=" }

  NotOp { "!" }

  UnknownOp { "?" }

  StarArgument { "*" }

  "{" "}" "(" ")" "[" "]" "." ".." "," ":" "->" "<->" "+" "-" "**" "=" "+="
}
