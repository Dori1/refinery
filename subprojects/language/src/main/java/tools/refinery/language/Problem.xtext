grammar tools.refinery.language.Problem with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "https://refinery.tools/emf/2021/Problem"

Problem:
	("problem" name=Identifier ".")?
	statements+=Statement*;

Statement:
	ClassDeclaration | EnumDeclaration |
	PredicateDefinition | FunctionDefinition | /* RuleDefinition | */
	Assertion | NodeValueAssertion |
	ScopeDeclaration | IndividualDeclaration;

ClassDeclaration:
	abstract?="abstract"? "class"
	name=Identifier
	("extends" superTypes+=[Relation|QualifiedName] ("," superTypes+=[Relation|QualifiedName])*)?
	("{" (referenceDeclarations+=ReferenceDeclaration ";"?)* "}" | ".");

EnumDeclaration:
	"enum"
	name=Identifier
	("{" (literals+=EnumLiteral ("," literals+=EnumLiteral)* ("," | ";")?)? "}" | ".");

EnumLiteral returns Node:
	name=Identifier;

enum ReferenceKind:
	REFERENCE="refers" | CONTAINMENT="contains" | CONTAINER="container";

ReferenceDeclaration:
	(kind=ReferenceKind referenceType=[Relation|QualifiedName] |
	referenceType=[Relation|NonRelationKindQualifiedName])
	("[" multiplicity=Multiplicity "]")?
	name=Identifier
	("opposite" opposite=[ReferenceDeclaration|QualifiedName])?;

enum ErrorKind returns PredicateKind:
	ERROR="error";

enum PredicateKind:
	ERROR="error" | CONTAINED="contained" | CONTAINMENT="containment";

PredicateDefinition:
	(kind=ErrorKind | kind=PredicateKind? "pred")
	name=Identifier
	"(" (parameters+=Parameter ("," parameters+=Parameter)*)? ")"
	("<->" bodies+=Conjunction (";" bodies+=Conjunction)*)?
	".";

Conjunction:
	literals+=Expr ("," literals+=Expr)*;

FunctionDefinition:
	functionType=[Relation|QualifiedName] name=Identifier
	"(" (parameters+=Parameter ("," parameters+=Parameter)*)? ")"
	("=" cases+=Case (";" cases+=Case)*)?
	".";

Case:
	Conjunction ({Match.condition=current} "->" value=Expr)?;

//RuleDefinition:
//	"rule"
//	name=Identifier
//	"(" (parameters+=Parameter ("," parameters+=Parameter)*)? ")"
//	(":" preconditions+=Conjunction (";" preconditions+=Conjunction)*)?
//	"==>" consequents+=Consequent (";" consequents+=Consequent)*)?
//	".";

Parameter:
	(modality=Modality? parameterType=[Relation|QualifiedName])? name=Identifier;

//Consequent:
//	actions+=Action ("," actions+=Action)*;
//
//Action:
//	AssertionAction | DeleteAction | NewAction;
//
//AssertionAction:
//	value=ShortLogicValue? atom=Atom |
//	atom=Atom (overwrite?=":=" | "<:") value=LogicValue;
//
//DeleteAction:
//	"delete" variableOrNode=[VariableOrNode|QualifiedName];
//
//NewAction:
//	"new" variable=NewVariable ("<:" parent=[VariableOrNode|QualifiedName])?;
//
//NewVariable:
//	name=Identifier;

Expr:
	ComparisonExpr;

enum ComparisonOp:
	LESS="<" | LESS_EQ="<=" | GREATER=">" | GREATER_EQ=">=" | EQ="==" | NOT_EQ="!=";

ComparisonExpr returns Expr:
	AdditiveExpr ({ComparisonExpr.left=current}
	op=ComparisonOp right=AdditiveExpr)*;

enum AdditiveOp returns BinaryOp:
	ADD="+" | SUB="-";

AdditiveExpr returns Expr:
	MultiplicativeExpr ({ArithmeticBinaryExpr.left=current}
	op=AdditiveOp right=MultiplicativeExpr)*;

enum MultiplicativeOp returns BinaryOp:
	MUL="*" | DIV="/";

MultiplicativeExpr returns Expr:
	ExponentialExpr ({ArithmeticBinaryExpr.left=current}
	op=MultiplicativeOp right=ExponentialExpr)*;

enum ExponentialOp returns BinaryOp:
	POW="**";

ExponentialExpr returns Expr:
	UnaryExpr ({ArithmeticBinaryExpr.left=current}
	op=ExponentialOp right=ExponentialExpr)?;

UnaryExpr returns Expr:
	ArithmeticUnaryExpr | ModalExpr | NegationExpr | CountExpr | AggregationExpr |
	Atom | VariableOrNodeExpr | ConstantExpr | "(" Expr ")";

enum UnaryOp:
	PLUS="+" | MINUS="-";

ArithmeticUnaryExpr:
	op=UnaryOp body=UnaryExpr;

enum Modality:
	MAY="may" | MUST="must" | CURRENT="current";

ModalExpr:
	modality=Modality body=UnaryExpr;

NegationExpr:
	"!" body=UnaryExpr;

CountExpr:
	"#" body=UnaryExpr;

enum AggregationOp:
	SUM="sum" | PROD="prod" | MIN="min" | MAX="max";

AggregationExpr:
	op=AggregationOp "{" value=Expr "|" condition=Expr "}";

Atom:
	relation=[Relation|QualifiedName]
	transitiveClosure?=TRANSITIVE_CLOSURE?
	"(" (arguments+=Expr ("," arguments+=Expr)*)? ")";

VariableOrNodeExpr:
	variableOrNode=[VariableOrNode|QualifiedName];

ConstantExpr:
	constant=Constant;

Assertion:
	default?="default"?
	(value=ShortLogicValue?
	relation=[Relation|QualifiedName]
	"(" (arguments+=AssertionArgument ("," arguments+=AssertionArgument)*)? ")"
	| relation=[Relation|QualifiedName]
	"(" (arguments+=AssertionArgument ("," arguments+=AssertionArgument)*)? ")"
	":" value=LogicValue)
	".";

AssertionArgument:
	NodeAssertionArgument | WildcardAssertionArgument | ConstantAssertionArgument;

NodeAssertionArgument:
	node=[Node|QualifiedName];

WildcardAssertionArgument:
	{WildcardAssertionArgument} "*";

ConstantAssertionArgument:
	negative?="-"? constant=Constant;

enum LogicValue:
	TRUE="true" | FALSE="false" | UNKNOWN="unknown" | ERROR="error";

enum ShortLogicValue returns LogicValue:
	FALSE="!" | UNKNOWN="?";

NodeValueAssertion:
	node=[Node|QualifiedName] ":" value=Constant ".";

Constant:
	RealConstant | IntConstant | StringConstant;

IntConstant:
	intValue=INT;

RealConstant:
	realValue=Real;

StringConstant:
	stringValue=STRING;

ScopeDeclaration:
	"scope" typeScopes+=TypeScope ("," typeScopes+=TypeScope)* ".";

TypeScope:
	targetType=[Relation|QualifiedName]
	(increment?="+=" | "=")
	multiplicity=DefiniteMultiplicity;

Multiplicity:
	UnboundedMultiplicity | DefiniteMultiplicity;

DefiniteMultiplicity returns Multiplicity:
	RangeMultiplicity | ExactMultiplicity;

UnboundedMultiplicity:
	{UnboundedMultiplicity};

RangeMultiplicity:
	lowerBound=INT ".." upperBound=UpperBound;

ExactMultiplicity:
	exactValue=INT;

IndividualDeclaration:
	"individual" nodes+=EnumLiteral ("," nodes+=EnumLiteral)* ".";

UpperBound returns ecore::EInt:
	INT | "*";

NonRelationKindQualifiedName hidden():
	NonRelationKindIdentifier ("::" Identifier)*;

QualifiedName hidden():
	Identifier ("::" Identifier)*;

NonRelationKindIdentifier:
	ID | "true" | "false" | "contained" | "sum" | "prod" | "min" | "max";

Identifier:
	NonRelationKindIdentifier | "contains";

Real returns ecore::EDouble:
	EXPONENTIAL | INT "." (INT | EXPONENTIAL);

terminal TRANSITIVE_CLOSURE:
	"synthetic:TRANSITIVE_CLOSURE";

@Override
terminal ID:
	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal EXPONENTIAL:
	INT ("e" | "E") ("+" | "-")? INT;

@Override
terminal SL_COMMENT:
	('%' | '//') !('\n' | '\r')* ('\r'? '\n')?;
